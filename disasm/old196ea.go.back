package disasm

// Opcodes Setup
////////////////..........

// byte to mnemonic map
var mnemonics = map[byte]string{

	//0x00: "SKIP",
	0x01: "CLR",
	0x02: "NOT",
	0x03: "NEG",
	0x04: "XCH",
	0x05: "DEC",
	0x06: "EXT",
	0x07: "INC",
	0x08: "SHR",
	0x09: "SHL",
	0x0A: "SHRA",
	0x0B: "XCH",
	0x0C: "SHRL",
	0x0D: "SHLL",
	0x0E: "SHRAL",
	0x0F: "NORML",
	0x10: "Reserved",
	0x11: "CLRB",
	0x12: "NOTB",
	0x13: "NEGB",
	0x14: "XCHB",
	0x15: "DECB",
	0x16: "EXTB",
	0x17: "INCB",
	0x18: "SHRB",
	0x19: "SHLB",
	0x1A: "SHRAB",
	0x1B: "XCHB",
	0x1C: "EST",
	0x1D: "EST",
	0x1E: "ESTB",
	0x1F: "ESTB",
	0x20: "SJMP",
	0x21: "SJMP",
	0x22: "SJMP",
	0x23: "SJMP",
	0x24: "SJMP",
	0x25: "SJMP",
	0x26: "SJMP",
	0x27: "SJMP",
	0x28: "SCALL",
	0x29: "SCALL",
	0x2A: "SCALL",
	0x2B: "SCALL",
	0x2C: "SCALL",
	0x2D: "SCALL",
	0x2E: "SCALL",
	0x2F: "SCALL",
	0x30: "JBC",
	0x31: "JBC",
	0x32: "JBC",
	0x33: "JBC",
	0x34: "JBC",
	0x35: "JBC",
	0x36: "JBC",
	0x37: "JBC",
	0x38: "JBS",
	0x39: "JBS",
	0x3A: "JBS",
	0x3B: "JBS",
	0x3C: "JBS",
	0x3D: "JBS",
	0x3E: "JBS",
	0x3F: "JBS",
	0x40: "AND",
	0x41: "AND",
	0x42: "AND",
	0x43: "AND",
	0x44: "ADD",
	0x45: "ADD",
	0x46: "ADD",
	0x47: "ADD",
	0x48: "SUB",
	0x49: "SUB",
	0x4A: "SUB",
	0x4B: "SUB",
	0x4C: "MULU",
	0x4D: "MULU",
	0x4E: "MULU",
	0x4F: "MULU",
	0x50: "ANDB",
	0x51: "ANDB",
	0x52: "ANDB",
	0x53: "ANDB",
	0x54: "ADDB",
	0x55: "ADDB",
	0x56: "ADDB",
	0x57: "ADDB",
	0x58: "SUBB",
	0x59: "SUBB",
	0x5A: "SUBB",
	0x5B: "SUBB",
	0x5C: "MULUB",
	0x5D: "MULUB",
	0x5E: "MULUB",
	0x5F: "MULUB",
	0x60: "AND",
	0x61: "AND",
	0x62: "AND",
	0x63: "AND",
	0x64: "ADD",
	0x65: "ADD",
	0x66: "ADD",
	0x67: "ADD",
	0x68: "SUB",
	0x69: "SUB",
	0x6A: "SUB",
	0x6B: "SUB",
	0x6C: "MULU",
	0x6D: "MULU",
	0x6E: "MULU",
	0x6F: "MULU",
	0x70: "ANDB",
	0x71: "ANDB",
	0x72: "ANDB",
	0x73: "ANDB",
	0x74: "ADDB",
	0x75: "ADDB",
	0x76: "ADDB",
	0x77: "ADDB",
	0x78: "SUBB",
	0x79: "SUBB",
	0x7A: "SUBB",
	0x7B: "SUBB",
	0x7C: "MULUB",
	0x7D: "MULUB",
	0x7E: "MULUB",
	0x7F: "MULUB",
	0x80: "OR",
	0x81: "OR",
	0x82: "OR",
	0x83: "OR",
	0x84: "XOR",
	0x85: "XOR",
	0x86: "XOR",
	0x87: "XOR",
	0x88: "CMP",
	0x89: "CMP",
	0x8A: "CMP",
	0x8B: "CMP",
	0x8C: "DIVU",
	0x8D: "DIVU",
	0x8E: "DIVU",
	0x8F: "DIVU",
	0x90: "ORB",
	0x91: "ORB",
	0x92: "ORB",
	0x93: "ORB",
	0x94: "XORB",
	0x95: "XORB",
	0x96: "XORB",
	0x97: "XORB",
	0x98: "CMPB",
	0x99: "CMPB",
	0x9A: "CMPB",
	0x9B: "CMPB",
	0x9C: "DIVUB",
	0x9D: "DIVUB",
	0x9E: "DIVUB",
	0x9F: "DIVUB",
	0xA0: "LD",
	0xA1: "LD",
	0xA2: "LD",
	0xA3: "LD",
	0xA4: "ADDC",
	0xA5: "ADDC",
	0xA6: "ADDC",
	0xA7: "ADDC",
	0xA8: "SUBC",
	0xA9: "SUBC",
	0xAA: "SUBC",
	0xAB: "SUBC",
	0xAC: "LDBZE",
	0xAD: "LDBZE",
	0xAE: "LDBZE",
	0xAF: "LDBZE",
	0xB0: "LDB",
	0xB1: "LDB",
	0xB2: "LDB",
	0xB3: "LDB",
	0xB4: "ADDCB",
	0xB5: "ADDCB",
	0xB6: "ADDCB",
	0xB7: "ADDCB",
	0xB8: "SUBCB",
	0xB9: "SUBCB",
	0xBA: "SUBCB",
	0xBB: "SUBCB",
	0xBC: "LDBSE",
	0xBD: "LDBSE",
	0xBE: "LDBSE",
	0xBF: "LDBSE",
	0xC0: "ST",
	0xC1: "BMOV",
	0xC2: "ST",
	0xC3: "ST",
	0xC4: "STB",
	0xC5: "CMPL",
	0xC6: "STB",
	0xC7: "STB",
	0xC8: "PUSH",
	0xC9: "PUSH",
	0xCA: "PUSH",
	0xCB: "PUSH",
	0xCC: "POP",
	0xCD: "BMOVI",
	0xCE: "POP",
	0xCF: "POP",
	0xD0: "JNST",
	0xD1: "JNH",
	0xD2: "JGT",
	0xD3: "JNC",
	0xD4: "JNVT",
	0xD5: "JNV",
	0xD6: "JGE",
	0xD7: "JNE",
	0xD8: "JST",
	0xD9: "JH",
	0xDA: "JLE",
	0xDB: "JC",
	0xDC: "JVT",
	0xDD: "JV",
	0xDE: "JLT",
	0xDF: "JE",
	0xE0: "DJNZ",
	0xE1: "DJNZW",
	0xE2: "TIJMP",
	0xE3: "EBR",
	0xE4: "EBMOVI",
	0xE5: "Reserved",
	0xE6: "EJMP",
	0xE7: "LJMP",
	0xE8: "ELD",
	0xE9: "ELD",
	0xEA: "ELDB",
	0xEB: "ELDB",
	0xEC: "DPTS",
	0xED: "EPTS",
	0xEE: "(Note 1) Reserved",
	0xEF: "LCALL",
	0xF0: "RET",
	0xF1: "ECALL",
	0xF2: "PUSHF",
	0xF3: "POPF",
	0xF4: "PUSHA",
	0xF5: "POPA",
	0xF6: "IDLPD",
	0xF7: "TRAP",
	0xF8: "CLRC",
	0xF9: "SETC",
	0xFA: "DI",
	0xFB: "EI",
	0xFC: "CLRVT",
	0xFD: "NOP",
	0xFE: "(Note 2) Prefix for signed multiplication and division.",
	//0xFF: "RST",
}

// byte to mnemonic
var mnemonicsSigned = map[byte]string{
	0x4C: "MUL",
	0x4D: "MUL",
	0x4E: "MUL",
	0x4F: "MUL",
	0x5C: "MULB",
	0x5D: "MULB",
	0x5E: "MULB",
	0x5F: "MULB",
	0x6C: "MUL",
	0x6D: "MUL",
	0x6E: "MUL",
	0x6F: "MUL",
	0x7C: "MULB",
	0x7D: "MULB",
	0x7E: "MULB",
	0x7F: "MULB",
	0x8C: "DIV",
	0x8D: "DIV",
	0x8E: "DIV",
	0x8F: "DIV",
	0x9C: "DIVB",
	0x9D: "DIVB",
	0x9E: "DIVB",
	0x9F: "DIVB",
}

var variableLengths = []byte{
	0x0B,
	0x1B,
	0x43,
	0x47,
	0x4B,
	0x4F,
	0x53,
	0x57,
	0x5B,
	0x5F,
	0x63,
	0x67,
	0x6B,
	0x6F,
	0x73,
	0x77,
	0x7B,
	0x7F,
	0x83,
	0x87,
	0x8B,
	0x8F,
	0x93,
	0x97,
	0x9B,
	0x9F,
	0xA3,
	0xA7,
	0xAB,
	0xAF,
	0xB3,
	0xB7,
	0xBB,
	0xBF,
	0xC3,
	0xC7,
	0xCB,
	0xCF,
}

var variableLengthsSigned = []byte{
	0x4F,
	0x5F,
	0x6F,
	0x7F,
	0x8F,
	0x9F,
}

var special = map[byte]string{
	0x10: "reserved",
	0xE5: "reserved",
	0xEE: "reserved",
	0xFE: "multi",
}

// byte to length for Signed ops
var byteLengthsSigned = map[byte]int{
	0x4C: 5,
	0x4D: 6,
	0x4E: 5,
	0x4F: 6, //	6/7
	0x5C: 5,
	0x5D: 5,
	0x5E: 5,
	0x5F: 6, //	6/7
	0x6C: 4,
	0x6D: 5,
	0x6E: 4,
	0x6F: 5, //	5/6
	0x7C: 4,
	0x7D: 4,
	0x7E: 4,
	0x7F: 5, //	5/6
	0x8C: 4,
	0x8D: 5,
	0x8E: 4,
	0x8F: 5, //	5/6
	0x9C: 4,
	0x9D: 4,
	0x9E: 4,
	0x9F: 5, //	5/6

}

// byte to length
var byteLengths = map[byte]int{
	0x00: 2,
	0x01: 2,
	0x02: 2,
	0x03: 2,
	0x04: 3,
	0x05: 2,
	0x06: 2,
	0x07: 2,
	0x08: 3,
	0x09: 3,
	0x0A: 3,
	0x0B: 4, //	4/5
	0x0C: 3,
	0x0D: 3,
	0x0E: 3,
	0x0F: 3,
	0x10: 1, //	Reserved
	0x11: 2,
	0x12: 2,
	0x13: 2,
	0x14: 3,
	0x15: 2,
	0x16: 2,
	0x17: 2,
	0x18: 3,
	0x19: 3,
	0x1A: 3,
	0x1B: 4, //	4/5
	0x1C: 3,
	0x1D: 6,
	0x1E: 3,
	0x1F: 6,
	0x20: 2,
	0x21: 2,
	0x22: 2,
	0x23: 2,
	0x24: 2,
	0x25: 2,
	0x26: 2,
	0x27: 2,
	0x28: 2,
	0x29: 2,
	0x2A: 2,
	0x2B: 2,
	0x2C: 2,
	0x2D: 2,
	0x2E: 2,
	0x2F: 2,
	0x30: 3,
	0x31: 3,
	0x32: 3,
	0x33: 3,
	0x34: 3,
	0x35: 3,
	0x36: 3,
	0x37: 3,
	0x38: 3,
	0x39: 3,
	0x3A: 3,
	0x3B: 3,
	0x3C: 3,
	0x3D: 3,
	0x3E: 3,
	0x3F: 3,
	0x40: 4,
	0x41: 5,
	0x42: 4,
	0x43: 5, //	5/6
	0x44: 4,
	0x45: 5,
	0x46: 4,
	0x47: 5, // 5/6
	0x48: 4,
	0x49: 5,
	0x4A: 4,
	0x4B: 5, //	5/6
	0x4C: 4,
	0x4D: 5,
	0x4E: 4,
	0x4F: 5, //	5/6
	0x50: 4,
	0x51: 4,
	0x52: 4,
	0x53: 5, //	5/6
	0x54: 4,
	0x55: 4,
	0x56: 4,
	0x57: 5, //	5/6
	0x58: 4,
	0x59: 4,
	0x5A: 4,
	0x5B: 5, //	5/6
	0x5C: 4,
	0x5D: 4,
	0x5E: 4,
	0x5F: 5, //	5/6
	0x60: 3,
	0x61: 4,
	0x62: 3,
	0x63: 4, //	4/5
	0x64: 3,
	0x65: 4,
	0x66: 3,
	0x67: 4, //	4/5
	0x68: 3,
	0x69: 4,
	0x6A: 3,
	0x6B: 4, //	4/5
	0x6C: 3,
	0x6D: 4,
	0x6E: 3,
	0x6F: 4, //	4/5
	0x70: 3,
	0x71: 3,
	0x72: 3,
	0x73: 4, //	4/5
	0x74: 3,
	0x75: 3,
	0x76: 3,
	0x77: 4, //	4/5
	0x78: 3,
	0x79: 3,
	0x7A: 3,
	0x7B: 4, //	4/5
	0x7C: 3,
	0x7D: 3,
	0x7E: 3,
	0x7F: 5, //	5/6
	0x80: 3,
	0x81: 4,
	0x82: 3,
	0x83: 4, //	4/5
	0x84: 3,
	0x85: 4,
	0x86: 3,
	0x87: 4, //	4/5
	0x88: 3,
	0x89: 4,
	0x8A: 3,
	0x8B: 4, //	4/5
	0x8C: 3,
	0x8D: 4,
	0x8E: 3,
	0x8F: 4, //	4/5
	0x90: 3,
	0x91: 3,
	0x92: 3,
	0x93: 4, //	4/5
	0x94: 3,
	0x95: 3,
	0x96: 3,
	0x97: 4, //	4/5
	0x98: 3,
	0x99: 3,
	0x9A: 3,
	0x9B: 4, //	4/5
	0x9C: 3,
	0x9D: 3,
	0x9E: 3,
	0x9F: 4, //	4/5
	0xA0: 3,
	0xA1: 4,
	0xA2: 3,
	0xA3: 4, //	4/5
	0xA4: 3,
	0xA5: 4,
	0xA6: 3,
	0xA7: 4, //	4/5
	0xA8: 3,
	0xA9: 4,
	0xAA: 3,
	0xAB: 4, //	4/5
	0xAC: 3,
	0xAD: 3,
	0xAE: 3,
	0xAF: 4, //	4/5
	0xB0: 3,
	0xB1: 3,
	0xB2: 3,
	0xB3: 4, //	4/5
	0xB4: 3,
	0xB5: 3,
	0xB6: 3,
	0xB7: 4, //	4/5
	0xB8: 3,
	0xB9: 3,
	0xBA: 3,
	0xBB: 4, //	4/5
	0xBC: 3,
	0xBD: 3,
	0xBE: 3,
	0xBF: 4, //	4/5
	0xC0: 3,
	0xC1: 3,
	0xC2: 3,
	0xC3: 4, //	4/5
	0xC4: 3,
	0xC5: 3,
	0xC6: 3,
	0xC7: 4, //	4/5
	0xC8: 2,
	0xC9: 3,
	0xCA: 2,
	0xCB: 3, //	3/4
	0xCC: 2,
	0xCD: 3,
	0xCE: 2,
	0xCF: 3, //	3/4
	0xD0: 2,
	0xD1: 2,
	0xD2: 2,
	0xD3: 2,
	0xD4: 2,
	0xD5: 2,
	0xD6: 2,
	0xD7: 2,
	0xD8: 2,
	0xD9: 2,
	0xDA: 2,
	0xDB: 2,
	0xDC: 2,
	0xDD: 2,
	0xDE: 2,
	0xDF: 2,
	0xE0: 3,
	0xE1: 3,
	0xE2: 4,
	0xE3: 2,
	0xE4: 3,
	0xE5: 1, //	Reserved
	0xE6: 4,
	0xE7: 3,
	0xE8: 3,
	0xE9: 6,
	0xEA: 3,
	0xEB: 6,
	0xEC: 1,
	0xED: 1,
	0xEE: 1, //	Reserved
	0xEF: 3,
	0xF0: 1,
	0xF1: 4,
	0xF2: 1,
	0xF3: 1,
	0xF4: 1,
	0xF5: 1,
	0xF6: 1,
	0xF7: 1,
	0xF8: 1,
	0xF9: 1,
	0xFA: 1,
	0xFB: 1,
	0xFC: 1,
	0xFD: 1,
	//0xFE:	,	// Multi
	0xFF: 1,
}

// byte to modes
var modes = map[byte]string{
	0x00: "direct",
	0x01: "direct",
	0x02: "direct",
	0x03: "direct",
	0x04: "direct",
	0x05: "n/a",
	0x06: "n/a",
	0x07: "n/a",
	0x08: "direct/immediate",
	0x09: "direct/immediate",
	0x0A: "direct/immediate",
	0x0B: "indexed",
	0x0C: "direct/immediate",
	0x0D: "direct/immediate",
	0x0E: "direct/immediate",
	0x0F: "direct/immediate",
	0x10: "RESERVED",
	0x11: "n/a",
	0x12: "direct",
	0x13: "direct",
	0x14: "direct",
	0x15: "n/a",
	0x16: "n/a",
	0x17: "n/a",
	0x18: "direct/immediate",
	0x19: "direct/immediate",
	0x1A: "direct/immediate",
	0x1B: "indexed",
	0x1C: "ex-indirect",
	0x1D: "ex-indexed",
	0x1E: "ex-indirect",
	0x1F: "ex-indexed",
	0x20: "indexed",
	0x21: "indexed",
	0x22: "indexed",
	0x23: "indexed",
	0x24: "indexed",
	0x25: "indexed",
	0x26: "indexed",
	0x27: "indexed",
	0x28: "indexed",
	0x29: "indexed",
	0x2A: "indexed",
	0x2B: "indexed",
	0x2C: "indexed",
	0x2D: "indexed",
	0x2E: "indexed",
	0x2F: "indexed",
	0x30: "indexed",
	0x31: "indexed",
	0x32: "indexed",
	0x33: "indexed",
	0x34: "indexed",
	0x35: "indexed",
	0x36: "indexed",
	0x37: "indexed",
	0x38: "indexed",
	0x39: "indexed",
	0x3A: "indexed",
	0x3B: "indexed",
	0x3C: "indexed",
	0x3D: "indexed",
	0x3E: "indexed",
	0x3F: "indexed",
	0x40: "direct",
	0x41: "immediate",
	0x42: "indirect",
	0x43: "indexed",
	0x44: "direct",
	0x45: "immediate",
	0x46: "indirect",
	0x47: "indexed",
	0x48: "direct",
	0x49: "immediate",
	0x4A: "indirect",
	0x4B: "indexed",
	0x4C: "direct",
	0x4D: "immediate",
	0x4E: "indirect",
	0x4F: "indexed",
	0x50: "direct",
	0x51: "immediate",
	0x52: "indirect",
	0x53: "indexed",
	0x54: "direct",
	0x55: "immediate",
	0x56: "indirect",
	0x57: "indexed",
	0x58: "direct",
	0x59: "immediate",
	0x5A: "indirect",
	0x5B: "indexed",
	0x5C: "direct",
	0x5D: "immediate",
	0x5E: "indirect",
	0x5F: "indexed",
	0x60: "direct",
	0x61: "immediate",
	0x62: "indirect",
	0x63: "indexed",
	0x64: "direct",
	0x65: "immediate",
	0x66: "indirect",
	0x67: "indexed",
	0x68: "direct",
	0x69: "immediate",
	0x6A: "indirect",
	0x6B: "indexed",
	0x6C: "direct",
	0x6D: "immediate",
	0x6E: "indirect",
	0x6F: "indexed",
	0x70: "direct",
	0x71: "immediate",
	0x72: "indirect",
	0x73: "indexed",
	0x74: "direct",
	0x75: "immediate",
	0x76: "indirect",
	0x77: "indexed",
	0x78: "direct",
	0x79: "immediate",
	0x7A: "indirect",
	0x7B: "indexed",
	0x7C: "direct",
	0x7D: "immediate",
	0x7E: "indirect",
	0x7F: "indexed",
	0x80: "direct",
	0x81: "immediate",
	0x82: "indirect",
	0x83: "indexed",
	0x84: "direct",
	0x85: "immediate",
	0x86: "indirect",
	0x87: "indexed",
	0x88: "direct",
	0x89: "immediate",
	0x8A: "indirect",
	0x8B: "indexed",
	0x8C: "direct",
	0x8D: "immediate",
	0x8E: "indirect",
	0x8F: "indexed",
	0x90: "direct",
	0x91: "immediate",
	0x92: "indirect",
	0x93: "indexed",
	0x94: "direct",
	0x95: "immediate",
	0x96: "indirect",
	0x97: "indexed",
	0x98: "direct",
	0x99: "immediate",
	0x9A: "indirect",
	0x9B: "indexed",
	0x9C: "direct",
	0x9D: "immediate",
	0x9E: "indirect",
	0x9F: "indexed",
	0xA0: "direct",
	0xA1: "immediate",
	0xA2: "indirect",
	0xA3: "indexed",
	0xA4: "direct",
	0xA5: "immediate",
	0xA6: "indirect",
	0xA7: "indexed",
	0xA8: "direct",
	0xA9: "immediate",
	0xAA: "indirect",
	0xAB: "indexed",
	0xAC: "direct",
	0xAD: "immediate",
	0xAE: "indirect",
	0xAF: "indexed",
	0xB0: "direct",
	0xB1: "immediate",
	0xB2: "indirect",
	0xB3: "indexed",
	0xB4: "direct",
	0xB5: "immediate",
	0xB6: "indirect",
	0xB7: "indexed",
	0xB8: "direct",
	0xB9: "immediate",
	0xBA: "indirect",
	0xBB: "indexed",
	0xBC: "direct",
	0xBD: "immediate",
	0xBE: "indirect",
	0xBF: "indexed",
	0xC0: "direct",
	0xC1: "indirect",
	0xC2: "indirect",
	0xC3: "indexed",
	0xC4: "direct",
	0xC5: "n/a",
	0xC6: "indirect",
	0xC7: "indexed",
	0xC8: "direct",
	0xC9: "immediate",
	0xCA: "indirect",
	0xCB: "indexed",
	0xCC: "direct",
	0xCD: "indirect",
	0xCE: "indirect",
	0xCF: "indexed",
	0xD0: "indexed",
	0xD1: "indexed",
	0xD2: "indexed",
	0xD3: "indexed",
	0xD4: "indexed",
	0xD5: "indexed",
	0xD6: "indexed",
	0xD7: "indexed",
	0xD8: "indexed",
	0xD9: "indexed",
	0xDA: "indexed",
	0xDB: "indexed",
	0xDC: "indexed",
	0xDD: "indexed",
	0xDE: "indexed",
	0xDF: "indexed",
	0xE0: "indexed",
	0xE1: "indexed",
	0xE2: "indexed",
	0xE3: "ex-indirect",
	0xE4: "ex-indirect",
	0xE5: "RESERVED",
	0xE6: "ex-indexed",
	0xE7: "indexed",
	0xE8: "ex-indirect",
	0xE9: "ex-indexed",
	0xEA: "ex-indirect",
	0xEB: "ex-indexed",
	0xEC: "direct",
	0xED: "direct",
	0xEE: "RESERVED",
	0xEF: "indexed",
	0xF0: "indirect",
	0xF1: "ex-indexed",
	0xF2: "direct",
	0xF3: "direct",
	0xF4: "direct",
	0xF5: "direct",
	0xF6: "immediate",
	0xF7: "direct",
	0xF8: "direct",
	0xF9: "direct",
	0xFA: "direct",
	0xFB: "direct",
	0xFC: "direct",
	0xFD: "direct",
	0xFE: "n/a",
	0xFF: "direct",
}

// byte to modes
var modesSigned = map[byte]string{}

// byte to description
var descriptions = map[byte]string{
	0x00: "SKIP TWO BYTE NO-OPERATION. Does nothing. Control passes to the next sequential instruction. This is actually a two-byte NOP in which the second byte can be any value and is simply ignored.",
	0x01: "CLR TWO BYTE NO-OPERATION. Clears the value of the operand.",
	0x02: "NOT COMPLEMENT WORD. Complements the value of the word operand (replaces each “1” with a “0” and each “0” with a “1”).",
	0x03: "NEG NEGATE INTEGER. Negates the value of the integer operand.",
	0x04: "EXCHANGE WORD. Exchanges the value of the source word operand with that of the destination word operand.",
	0x05: "DEC DECREMENT WORD. Decrements the value of the operand by one.",
	0x06: "EXT SIGN-EXTEND INTEGER INTO LONGINTEGER. Sign-extends the low-order word of the operand throughout the high-order word of the operand.",
	0x07: "INC INCREMENT WORD. Increments the value of the word operand by 1.",
	0x08: "SHR LOGICAL RIGHT SHIFT WORD. Shifts the destination word operand to the right as many times as specified by the count operand. The count may be specified either as an immediate value in the range of 0 to 15 (0FH), inclusive, or as the content of any register (10–0FFH) with a value in the range of 0 to 31 (1FH), inclusive. The left bits of the result are filled with zeros. The last bit shifted out is saved in the carry flag.",
	0x09: "SHL SHIFT WORD LEFT. Shifts the destination word operand to the left as many times as specified by the count operand. The count may be specified either as an immediate value in the range of 0 to 15 (0FH), inclusive, or as the content of any register (10–0FFH) with a value in the range of 0 to 31 (1FH), inclusive. The right bits of the result are filled with zeros. The last bit shifted out is saved in the carry flag.",
	0x0A: "SHRA ARITHMETIC RIGHT SHIFT WORD. Shifts the destination word operand to the right as many times as specified by the count operand. The count may be specified either as an immediate value in the range of 0 to 15 (0FH), inclusive, or as the content of any register (10–0FFH) with a value in the range of 0 to 31 (1FH), inclusive. If the original high order bit value was “0,” zeros are shifted in. If the value was “1,” ones are shifted in. The last bit shifted out is saved in the carry flag.",
	0x0B: "XCH EXCHANGE WORD. Exchanges the value of the source word operand with that of the destination word operand.",
	0x0C: "SHRL LOGICAL RIGHT SHIFT DOUBLE-WORD. Shifts the destination double-word operand to the right as many times as specified by the count operand. The count may be specified either as an immediate value in the range of 0 to 15 (0FH), inclusive, or as the content of any register (10–0FFH) with a value in the range of 0 to 31 (1FH), inclusive. The left bits of the result are filled with zeros. The last bit shifted out is saved in the carry flag.",
	0x0D: "SHLL SHIFT DOUBLE-WORD LEFT. Shifts the destination double-word operand to the left as many times as specified by the count operand. The count may be specified either as an immediate value in the range of 0 to 15 (0FH), inclusive, or as the content of any register (10–0FFH) with a value in the range of 0 to 31 (1FH), inclusive. The right bits of the result are filled with zeros. The last bit shifted out is saved in the carry flag.",
	0x0E: "SHRAL ARITHMETIC RIGHT SHIFT DOUBLEWORD. Shifts the destination double-word operand to the right as many times as specified by the count operand. The count may be specified either as an immediate value in the range of 0 to 15 (0FH), inclusive, or as the content of any register (10–0FFH) with a value in the range of 0 to 31 (1FH), inclusive. If the original high order bit value was “0,” zeros are shifted in. If the value was “1,” ones are shifted in.",
	0x0F: "NORML NORMALIZE LONG-INTEGER. Normalizes the source (leftmost) long-integer operand. (That is, it shifts the operand to the left until its most significant bit is “1” or until it has performed 31 shifts). If the most significant bit is still “0” after 31 shifts, the instruction stops the process and sets the zero flag. The instruction stores the actual number of shifts performed in the destination (rightmost) operand.",
	0x10: "Reserved",
	0x11: "CLRB CLEAR BYTE. Clears the value of the operand.",
	0x12: "NOTB COMPLEMENT BYTE. Complements the value of the byte operand (replaces each “1” with a “0” and each “0” with a “1”).",
	0x13: "NEGB NEGATE SHORT-INTEGER. Negates the value of the short-integer operand.",
	0x14: "XCHB EXCHANGE BYTE. Exchanges the value of the source byte operand with that of the destination byte operand.",
	0x15: "DECB DECREMENT BYTE. Decrements the value of the operand by one.",
	0x16: "EXTB SIGN-EXTEND SHORT-INTEGER INTO INTEGER. Sign-extends the low-order byte of the operand throughout the high-order byte of the operand.",
	0x17: "INCB INCREMENT BYTE. Increments the value of the byte operand by 1.",
	0x18: "SHRB LOGICAL RIGHT SHIFT BYTE. Shifts the destination byte operand to the right as many times as specified by the count operand. The count may be specified either as an immediate value in the range of 0 to 15 (0FH), inclusive, or as the content of any register (10–0FFH) with a value in the range of 0 to 31 (1FH), inclusive. The left bits of the result are filled with zeros. The last bit shifted out is saved in the carry flag.",
	0x19: "SHLB SHIFT BYTE LEFT. Shifts the destination byte operand to the left as many times as specified by the count operand. The count may be specified either as an immediate value in the range of 0 to 15 (0FH), inclusive, or as the content of any register (10–0FFH) with a value in the range of 0 to 31 (1FH), inclusive. The right bits of the result are filled with zeros. The last bit shifted out is saved in the carry flag.",
	0x1A: "SHRAB ARITHMETIC RIGHT SHIFT BYTE. Shifts the destination byte operand to the right as many times as specified by the count operand. The count may be specified either as an immediate value in the range of 0 to 15 (0FH), inclusive, or as the content of any register (10–0FFH) with a value in the range of 0 to 31 (1FH), inclusive. If the original high order bit value was “0,” zeros are shifted in. If the value was “1,” ones are shifted in. The last bit shifted out is saved in the carry flag.",
	0x1B: "XCHB EXCHANGE BYTE. Exchanges the value of the source byte operand with that of the destination byte operand.",
	0x1C: "EST EXTENDED STORE WORD. Stores the value of the source (leftmost) word operand into the destination (rightmost) operand. This instruction allows you to move data from the lower register file to anywhere in the 16- Mbyte address space.",
	0x1D: "EST EXTENDED STORE WORD. Stores the value of the source (leftmost) word operand into the destination (rightmost) operand. This instruction allows you to move data from the lower register file to anywhere in the 16- Mbyte address space.",
	0x1E: "ESTB EXTENDED STORE BYTE. Stores the value of the source (leftmost) byte operand into the destination (rightmost) operand. This instruction allows you to move data from the lower register file to anywhere in the 16- Mbyte address space.",
	0x1F: "ESTB EXTENDED STORE BYTE. Stores the value of the source (leftmost) byte operand into the destination (rightmost) operand. This instruction allows you to move data from the lower register file to anywhere in the 16- Mbyte address space.",
	0x20: "SJMP SHORT JUMP. Adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –1024 to +1023, inclusive.",
	0x21: "SJMP SHORT JUMP. Adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –1024 to +1023, inclusive.",
	0x22: "SJMP SHORT JUMP. Adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –1024 to +1023, inclusive.",
	0x23: "SJMP SHORT JUMP. Adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –1024 to +1023, inclusive.",
	0x24: "SJMP SHORT JUMP. Adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –1024 to +1023, inclusive.",
	0x25: "SJMP SHORT JUMP. Adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –1024 to +1023, inclusive.",
	0x26: "SJMP SHORT JUMP. Adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –1024 to +1023, inclusive.",
	0x27: "SJMP SHORT JUMP. Adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –1024 to +1023, inclusive.",
	0x28: "SCALL SHORT CALL. Pushes the contents of the program counter (the return address) onto the stack, then adds to the program counter the offset between the end of this instruction and the target label, effecting the call. The offset must be in the range of –1024 to +1023.",
	0x29: "SCALL SHORT CALL. Pushes the contents of the program counter (the return address) onto the stack, then adds to the program counter the offset between the end of this instruction and the target label, effecting the call. The offset must be in the range of –1024 to +1023.",
	0x2A: "SCALL SHORT CALL. Pushes the contents of the program counter (the return address) onto the stack, then adds to the program counter the offset between the end of this instruction and the target label, effecting the call. The offset must be in the range of –1024 to +1023.",
	0x2B: "SCALL SHORT CALL. Pushes the contents of the program counter (the return address) onto the stack, then adds to the program counter the offset between the end of this instruction and the target label, effecting the call. The offset must be in the range of –1024 to +1023.",
	0x2C: "SCALL SHORT CALL. Pushes the contents of the program counter (the return address) onto the stack, then adds to the program counter the offset between the end of this instruction and the target label, effecting the call. The offset must be in the range of –1024 to +1023.",
	0x2D: "SCALL SHORT CALL. Pushes the contents of the program counter (the return address) onto the stack, then adds to the program counter the offset between the end of this instruction and the target label, effecting the call. The offset must be in the range of –1024 to +1023.",
	0x2E: "SCALL SHORT CALL. Pushes the contents of the program counter (the return address) onto the stack, then adds to the program counter the offset between the end of this instruction and the target label, effecting the call. The offset must be in the range of –1024 to +1023.",
	0x2F: "SCALL SHORT CALL. Pushes the contents of the program counter (the return address) onto the stack, then adds to the program counter the offset between the end of this instruction and the target label, effecting the call. The offset must be in the range of –1024 to +1023.",
	0x30: "JBC JUMP IF BIT IS CLEAR. Tests the specified bit. If the bit is set, control passes to the next sequential instruction. If the bit is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x31: "JBC JUMP IF BIT IS CLEAR. Tests the specified bit. If the bit is set, control passes to the next sequential instruction. If the bit is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x32: "JBC JUMP IF BIT IS CLEAR. Tests the specified bit. If the bit is set, control passes to the next sequential instruction. If the bit is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x33: "JBC JUMP IF BIT IS CLEAR. Tests the specified bit. If the bit is set, control passes to the next sequential instruction. If the bit is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x34: "JBC JUMP IF BIT IS CLEAR. Tests the specified bit. If the bit is set, control passes to the next sequential instruction. If the bit is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x35: "JBC JUMP IF BIT IS CLEAR. Tests the specified bit. If the bit is set, control passes to the next sequential instruction. If the bit is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x36: "JBC JUMP IF BIT IS CLEAR. Tests the specified bit. If the bit is set, control passes to the next sequential instruction. If the bit is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x37: "JBC JUMP IF BIT IS CLEAR. Tests the specified bit. If the bit is set, control passes to the next sequential instruction. If the bit is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x38: "JBS JUMP IF BIT IS SET. Tests the specified bit. If the bit is clear, control passes to the next sequential instruction. If the bit is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x39: "JBS JUMP IF BIT IS SET. Tests the specified bit. If the bit is clear, control passes to the next sequential instruction. If the bit is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x3A: "JBS JUMP IF BIT IS SET. Tests the specified bit. If the bit is clear, control passes to the next sequential instruction. If the bit is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x3B: "JBS JUMP IF BIT IS SET. Tests the specified bit. If the bit is clear, control passes to the next sequential instruction. If the bit is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x3C: "JBS JUMP IF BIT IS SET. Tests the specified bit. If the bit is clear, control passes to the next sequential instruction. If the bit is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x3D: "JBS JUMP IF BIT IS SET. Tests the specified bit. If the bit is clear, control passes to the next sequential instruction. If the bit is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x3E: "JBS JUMP IF BIT IS SET. Tests the specified bit. If the bit is clear, control passes to the next sequential instruction. If the bit is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x3F: "JBS JUMP IF BIT IS SET. Tests the specified bit. If the bit is clear, control passes to the next sequential instruction. If the bit is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0x40: "AND (3 operands) LOGICAL AND WORDS. ANDs the two source word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x41: "AND (3 operands) LOGICAL AND WORDS. ANDs the two source word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x42: "AND (3 operands) LOGICAL AND WORDS. ANDs the two source word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x43: "AND (3 operands) LOGICAL AND WORDS. ANDs the two source word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x44: "AND (3 operands) LOGICAL AND WORDS. ANDs the two source word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x45: "AND (3 operands) LOGICAL AND WORDS. ANDs the two source word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x46: "AND (3 operands) LOGICAL AND WORDS. ANDs the two source word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x47: "AND (3 operands) LOGICAL AND WORDS. ANDs the two source word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x48: "SUB (3 operands) SUBTRACT WORDS. Subtracts the first source word operand from the second, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x49: "SUB (3 operands) SUBTRACT WORDS. Subtracts the first source word operand from the second, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x4A: "SUB (3 operands) SUBTRACT WORDS. Subtracts the first source word operand from the second, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x4B: "SUB (3 operands) SUBTRACT WORDS. Subtracts the first source word operand from the second, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x4C: "MUL (3 operands) MULTIPLY INTEGERS. Multiplies the two source integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x4D: "MUL (3 operands) MULTIPLY INTEGERS. Multiplies the two source integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x4E: "MUL (3 operands) MULTIPLY INTEGERS. Multiplies the two source integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x4F: "MUL (3 operands) MULTIPLY INTEGERS. Multiplies the two source integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x50: "ANDB (3 operands) LOGICAL AND BYTES. ANDs the two source byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x51: "ANDB (3 operands) LOGICAL AND BYTES. ANDs the two source byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x52: "ANDB (3 operands) LOGICAL AND BYTES. ANDs the two source byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x53: "ANDB (3 operands) LOGICAL AND BYTES. ANDs the two source byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x54: "ANDB (3 operands) LOGICAL AND BYTES. ANDs the two source byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x55: "ANDB (3 operands) LOGICAL AND BYTES. ANDs the two source byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x56: "ANDB (3 operands) LOGICAL AND BYTES. ANDs the two source byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x57: "ANDB (3 operands) LOGICAL AND BYTES. ANDs the two source byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x58: "SUBB (3 operands) SUBTRACT BYTES. Subtracts the second source byte operand from the first, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x59: "SUBB (3 operands) SUBTRACT BYTES. Subtracts the second source byte operand from the first, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x5A: "SUBB (3 operands) SUBTRACT BYTES. Subtracts the second source byte operand from the first, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x5B: "SUBB (3 operands) SUBTRACT BYTES. Subtracts the second source byte operand from the first, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x5C: "MULUB (3 operands) MULTIPLY BYTES, UNSIGNED. Multiplies the two source byte operands, using unsigned arithmetic, and stores the word result into the destination operand. The sticky bit flag is undefined after the instruction is executed.",
	0x5D: "MULUB (3 operands) MULTIPLY BYTES, UNSIGNED. Multiplies the two source byte operands, using unsigned arithmetic, and stores the word result into the destination operand. The sticky bit flag is undefined after the instruction is executed.",
	0x5E: "MULUB (3 operands) MULTIPLY BYTES, UNSIGNED. Multiplies the two source byte operands, using unsigned arithmetic, and stores the word result into the destination operand. The sticky bit flag is undefined after the instruction is executed.",
	0x5F: "MULUB (3 operands) MULTIPLY BYTES, UNSIGNED. Multiplies the two source byte operands, using unsigned arithmetic, and stores the word result into the destination operand. The sticky bit flag is undefined after the instruction is executed.",
	0x60: "AND (2 operands) LOGICAL AND WORDS. ANDs the source and destination word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x61: "AND (2 operands) LOGICAL AND WORDS. ANDs the source and destination word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x62: "AND (2 operands) LOGICAL AND WORDS. ANDs the source and destination word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x63: "AND (2 operands) LOGICAL AND WORDS. ANDs the source and destination word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x64: "AND (2 operands) LOGICAL AND WORDS. ANDs the source and destination word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x65: "AND (2 operands) LOGICAL AND WORDS. ANDs the source and destination word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x66: "AND (2 operands) LOGICAL AND WORDS. ANDs the source and destination word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x67: "AND (2 operands) LOGICAL AND WORDS. ANDs the source and destination word operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x68: "SUB (2 operands) SUBTRACT WORDS. Subtracts the source word operand from the destination word operand, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x69: "SUB (2 operands) SUBTRACT WORDS. Subtracts the source word operand from the destination word operand, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x6A: "SUB (2 operands) SUBTRACT WORDS. Subtracts the source word operand from the destination word operand, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x6B: "SUB (2 operands) SUBTRACT WORDS. Subtracts the source word operand from the destination word operand, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x6C: "MULU (2 operands) MULTIPLY WORDS, UNSIGNED. Multiplies the source and destination word operands, using unsigned arithmetic, and stores the 32- bit result into the destination double-word operand. The sticky bit flag is undefined after the instruction is executed.",
	0x6D: "MULU (2 operands) MULTIPLY WORDS, UNSIGNED. Multiplies the source and destination word operands, using unsigned arithmetic, and stores the 32- bit result into the destination double-word operand. The sticky bit flag is undefined after the instruction is executed.",
	0x6E: "MULU (2 operands) MULTIPLY WORDS, UNSIGNED. Multiplies the source and destination word operands, using unsigned arithmetic, and stores the 32- bit result into the destination double-word operand. The sticky bit flag is undefined after the instruction is executed.",
	0x6F: "MULU (2 operands) MULTIPLY WORDS, UNSIGNED. Multiplies the source and destination word operands, using unsigned arithmetic, and stores the 32- bit result into the destination double-word operand. The sticky bit flag is undefined after the instruction is executed.",
	0x70: "ANDB (2 operands) LOGICAL AND BYTES. ANDs the source and destination byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x71: "ANDB (2 operands) LOGICAL AND BYTES. ANDs the source and destination byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x72: "ANDB (2 operands) LOGICAL AND BYTES. ANDs the source and destination byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x73: "ANDB (2 operands) LOGICAL AND BYTES. ANDs the source and destination byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x74: "ANDB (2 operands) LOGICAL AND BYTES. ANDs the source and destination byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x75: "ANDB (2 operands) LOGICAL AND BYTES. ANDs the source and destination byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x76: "ANDB (2 operands) LOGICAL AND BYTES. ANDs the source and destination byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x77: "ANDB (2 operands) LOGICAL AND BYTES. ANDs the source and destination byte operands and stores the result into the destination operand. The result has ones in only the bit positions in which both operands had a “1” and zeros in all other bit positions.",
	0x78: "SUBB (2 operands) SUBTRACT BYTES. Subtracts the source byte operand from the destination byte operand, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x79: "SUBB (2 operands) SUBTRACT BYTES. Subtracts the source byte operand from the destination byte operand, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x7A: "SUBB (2 operands) SUBTRACT BYTES. Subtracts the source byte operand from the destination byte operand, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x7B: "SUBB (2 operands) SUBTRACT BYTES. Subtracts the source byte operand from the destination byte operand, stores the result in the destination operand, and sets the carry flag as the complement of borrow.",
	0x7C: "MULUB (2 operands) MULTIPLY BYTES, UNSIGNED. Multiplies the source and destination operands, using unsigned arithmetic, and stores the word result into the destination operand. The sticky bit flag is undefined after the instruction is executed.",
	0x7D: "MULUB (2 operands) MULTIPLY BYTES, UNSIGNED. Multiplies the source and destination operands, using unsigned arithmetic, and stores the word result into the destination operand. The sticky bit flag is undefined after the instruction is executed.",
	0x7E: "MULUB (2 operands) MULTIPLY BYTES, UNSIGNED. Multiplies the source and destination operands, using unsigned arithmetic, and stores the word result into the destination operand. The sticky bit flag is undefined after the instruction is executed.",
	0x7F: "MULUB (2 operands) MULTIPLY BYTES, UNSIGNED. Multiplies the source and destination operands, using unsigned arithmetic, and stores the word result into the destination operand. The sticky bit flag is undefined after the instruction is executed.",
	0x80: "OR LOGICAL OR WORDS. ORs the source word operand with the destination word operand and replaces the original destination operand with the result. The result has a “1” in each bit position in which either the source or destination operand had a “1”.",
	0x81: "OR LOGICAL OR WORDS. ORs the source word operand with the destination word operand and replaces the original destination operand with the result. The result has a “1” in each bit position in which either the source or destination operand had a “1”.",
	0x82: "OR LOGICAL OR WORDS. ORs the source word operand with the destination word operand and replaces the original destination operand with the result. The result has a “1” in each bit position in which either the source or destination operand had a “1”.",
	0x83: "OR LOGICAL OR WORDS. ORs the source word operand with the destination word operand and replaces the original destination operand with the result. The result has a “1” in each bit position in which either the source or destination operand had a “1”.",
	0x84: "XOR LOGICAL EXCLUSIVE-OR WORDS. XORs the source word operand with the destination word operand and stores the result in the destination operand. The result has ones in the bit positions in which either operand (but not both) had a “1” and zeros in all other bit positions.",
	0x85: "XOR LOGICAL EXCLUSIVE-OR WORDS. XORs the source word operand with the destination word operand and stores the result in the destination operand. The result has ones in the bit positions in which either operand (but not both) had a “1” and zeros in all other bit positions.",
	0x86: "XOR LOGICAL EXCLUSIVE-OR WORDS. XORs the source word operand with the destination word operand and stores the result in the destination operand. The result has ones in the bit positions in which either operand (but not both) had a “1” and zeros in all other bit positions.",
	0x87: "XOR LOGICAL EXCLUSIVE-OR WORDS. XORs the source word operand with the destination word operand and stores the result in the destination operand. The result has ones in the bit positions in which either operand (but not both) had a “1” and zeros in all other bit positions.",
	0x88: "CMP COMPARE WORDS. Subtracts the source word operand from the destination word operand. The flags are altered, but the operands remain unaffected. If a borrow occurs, the carry flag is cleared; otherwise, it is set.",
	0x89: "CMP COMPARE WORDS. Subtracts the source word operand from the destination word operand. The flags are altered, but the operands remain unaffected. If a borrow occurs, the carry flag is cleared; otherwise, it is set.",
	0x8A: "CMP COMPARE WORDS. Subtracts the source word operand from the destination word operand. The flags are altered, but the operands remain unaffected. If a borrow occurs, the carry flag is cleared; otherwise, it is set.",
	0x8B: "CMP COMPARE WORDS. Subtracts the source word operand from the destination word operand. The flags are altered, but the operands remain unaffected. If a borrow occurs, the carry flag is cleared; otherwise, it is set.",
	0x8C: "DIVU DIVIDE WORDS, UNSIGNED. Divides the contents of the destination double-word operand by the contents of the source word operand, using unsigned arithmetic. It stores the quotient into the low-order word (i.e., the word with the lower address) of the destination operand and the remainder into the high-order word. The following two statements are performed concurrently.",
	0x8D: "DIVU DIVIDE WORDS, UNSIGNED. Divides the contents of the destination double-word operand by the contents of the source word operand, using unsigned arithmetic. It stores the quotient into the low-order word (i.e., the word with the lower address) of the destination operand and the remainder into the high-order word. The following two statements are performed concurrently.",
	0x8E: "DIVU DIVIDE WORDS, UNSIGNED. Divides the contents of the destination double-word operand by the contents of the source word operand, using unsigned arithmetic. It stores the quotient into the low-order word (i.e., the word with the lower address) of the destination operand and the remainder into the high-order word. The following two statements are performed concurrently.",
	0x8F: "DIVU DIVIDE WORDS, UNSIGNED. Divides the contents of the destination double-word operand by the contents of the source word operand, using unsigned arithmetic. It stores the quotient into the low-order word (i.e., the word with the lower address) of the destination operand and the remainder into the high-order word. The following two statements are performed concurrently.",
	0x90: "ORB LOGICAL OR BYTES. ORs the source byte operand with the destination byte operand and replaces the original destination operand with the result. The result has a “1” in each bit position in which either the source or destination operand had a “1”.",
	0x91: "ORB LOGICAL OR BYTES. ORs the source byte operand with the destination byte operand and replaces the original destination operand with the result. The result has a “1” in each bit position in which either the source or destination operand had a “1”.",
	0x92: "ORB LOGICAL OR BYTES. ORs the source byte operand with the destination byte operand and replaces the original destination operand with the result. The result has a “1” in each bit position in which either the source or destination operand had a “1”.",
	0x93: "ORB LOGICAL OR BYTES. ORs the source byte operand with the destination byte operand and replaces the original destination operand with the result. The result has a “1” in each bit position in which either the source or destination operand had a “1”.",
	0x94: "XORB LOGICAL EXCLUSIVE-OR BYTES. XORs the source byte operand with the destination byte operand and stores the result in the destination operand. The result has ones in the bit positions in which either operand (but not both) had a “1” and zeros in all other bit positions.",
	0x95: "XORB LOGICAL EXCLUSIVE-OR BYTES. XORs the source byte operand with the destination byte operand and stores the result in the destination operand. The result has ones in the bit positions in which either operand (but not both) had a “1” and zeros in all other bit positions.",
	0x96: "XORB LOGICAL EXCLUSIVE-OR BYTES. XORs the source byte operand with the destination byte operand and stores the result in the destination operand. The result has ones in the bit positions in which either operand (but not both) had a “1” and zeros in all other bit positions.",
	0x97: "XORB LOGICAL EXCLUSIVE-OR BYTES. XORs the source byte operand with the destination byte operand and stores the result in the destination operand. The result has ones in the bit positions in which either operand (but not both) had a “1” and zeros in all other bit positions.",
	0x98: "CMPB COMPARE BYTES. Subtracts the source byte operand from the destination byte operand. The flags are altered, but the operands remain unaffected. If a borrow occurs, the carry flag is cleared; otherwise, it is set.",
	0x99: "CMPB COMPARE BYTES. Subtracts the source byte operand from the destination byte operand. The flags are altered, but the operands remain unaffected. If a borrow occurs, the carry flag is cleared; otherwise, it is set.",
	0x9A: "CMPB COMPARE BYTES. Subtracts the source byte operand from the destination byte operand. The flags are altered, but the operands remain unaffected. If a borrow occurs, the carry flag is cleared; otherwise, it is set.",
	0x9B: "CMPB COMPARE BYTES. Subtracts the source byte operand from the destination byte operand. The flags are altered, but the operands remain unaffected. If a borrow occurs, the carry flag is cleared; otherwise, it is set.",
	0x9C: "DIVUB DIVIDE BYTES, UNSIGNED. This instruction divides the contents of the destination word operand by the contents of the source byte operand, using unsigned arithmetic. It stores the quotient into the low-order byte (i.e., the byte with the lower address) of the destination operand and the remainder into the high-order byte. The following two statements are performed concurrently.",
	0x9D: "DIVUB DIVIDE BYTES, UNSIGNED. This instruction divides the contents of the destination word operand by the contents of the source byte operand, using unsigned arithmetic. It stores the quotient into the low-order byte (i.e., the byte with the lower address) of the destination operand and the remainder into the high-order byte. The following two statements are performed concurrently.",
	0x9E: "DIVUB DIVIDE BYTES, UNSIGNED. This instruction divides the contents of the destination word operand by the contents of the source byte operand, using unsigned arithmetic. It stores the quotient into the low-order byte (i.e., the byte with the lower address) of the destination operand and the remainder into the high-order byte. The following two statements are performed concurrently.",
	0x9F: "DIVUB DIVIDE BYTES, UNSIGNED. This instruction divides the contents of the destination word operand by the contents of the source byte operand, using unsigned arithmetic. It stores the quotient into the low-order byte (i.e., the byte with the lower address) of the destination operand and the remainder into the high-order byte. The following two statements are performed concurrently.",
	0xA0: "LD LOAD WORD. Loads the value of the source word operand into the destination operand.",
	0xA1: "LD LOAD WORD. Loads the value of the source word operand into the destination operand.",
	0xA2: "LD LOAD WORD. Loads the value of the source word operand into the destination operand.",
	0xA3: "LD LOAD WORD. Loads the value of the source word operand into the destination operand.",
	0xA4: "ADDC ADD WORDS WITH CARRY. Adds the source and destination word operands and the carry flag (0 or 1) and stores the sum into the destination operand.",
	0xA5: "ADDC ADD WORDS WITH CARRY. Adds the source and destination word operands and the carry flag (0 or 1) and stores the sum into the destination operand.",
	0xA6: "ADDC ADD WORDS WITH CARRY. Adds the source and destination word operands and the carry flag (0 or 1) and stores the sum into the destination operand.",
	0xA7: "ADDC ADD WORDS WITH CARRY. Adds the source and destination word operands and the carry flag (0 or 1) and stores the sum into the destination operand.",
	0xA8: "SUBC SUBTRACT WORDS WITH BORROW. Subtracts the source word operand from the destination word operand. If the carry flag was clear, SUBC subtracts 1 from the result. It stores the result in the destination operand and sets the carry flag as the complement of borrow.",
	0xA9: "SUBC SUBTRACT WORDS WITH BORROW. Subtracts the source word operand from the destination word operand. If the carry flag was clear, SUBC subtracts 1 from the result. It stores the result in the destination operand and sets the carry flag as the complement of borrow.",
	0xAA: "SUBC SUBTRACT WORDS WITH BORROW. Subtracts the source word operand from the destination word operand. If the carry flag was clear, SUBC subtracts 1 from the result. It stores the result in the destination operand and sets the carry flag as the complement of borrow.",
	0xAB: "SUBC SUBTRACT WORDS WITH BORROW. Subtracts the source word operand from the destination word operand. If the carry flag was clear, SUBC subtracts 1 from the result. It stores the result in the destination operand and sets the carry flag as the complement of borrow.",
	0xAC: "LDBZE LOAD BYTE ZERO-EXTENDED. Zeroextends the value of the source byte operand and loads it into the destination word operand.",
	0xAD: "LDBZE LOAD BYTE ZERO-EXTENDED. Zeroextends the value of the source byte operand and loads it into the destination word operand.",
	0xAE: "LDBZE LOAD BYTE ZERO-EXTENDED. Zeroextends the value of the source byte operand and loads it into the destination word operand.",
	0xAF: "LDBZE LOAD BYTE ZERO-EXTENDED. Zeroextends the value of the source byte operand and loads it into the destination word operand.",
	0xB0: "LDB LOAD BYTE. Loads the value of the source byte operand into the destination operand.",
	0xB1: "LDB LOAD BYTE. Loads the value of the source byte operand into the destination operand.",
	0xB2: "LDB LOAD BYTE. Loads the value of the source byte operand into the destination operand.",
	0xB3: "LDB LOAD BYTE. Loads the value of the source byte operand into the destination operand.",
	0xB4: "ADDCB ADD BYTES WITH CARRY. Adds the source and destination byte operands and the carry flag (0 or 1) and stores the sum into the destination operand.",
	0xB5: "ADDCB ADD BYTES WITH CARRY. Adds the source and destination byte operands and the carry flag (0 or 1) and stores the sum into the destination operand.",
	0xB6: "ADDCB ADD BYTES WITH CARRY. Adds the source and destination byte operands and the carry flag (0 or 1) and stores the sum into the destination operand.",
	0xB7: "ADDCB ADD BYTES WITH CARRY. Adds the source and destination byte operands and the carry flag (0 or 1) and stores the sum into the destination operand.",
	0xB8: "SUBCB SUBTRACT BYTES WITH BORROW. Subtracts the source byte operand from the destination byte operand. If the carry flag was clear, SUBCB subtracts 1 from the result. It stores the result in the destination operand and sets the carry flag as the complement of borrow.",
	0xB9: "SUBCB SUBTRACT BYTES WITH BORROW. Subtracts the source byte operand from the destination byte operand. If the carry flag was clear, SUBCB subtracts 1 from the result. It stores the result in the destination operand and sets the carry flag as the complement of borrow.",
	0xBA: "SUBCB SUBTRACT BYTES WITH BORROW. Subtracts the source byte operand from the destination byte operand. If the carry flag was clear, SUBCB subtracts 1 from the result. It stores the result in the destination operand and sets the carry flag as the complement of borrow.",
	0xBB: "SUBCB SUBTRACT BYTES WITH BORROW. Subtracts the source byte operand from the destination byte operand. If the carry flag was clear, SUBCB subtracts 1 from the result. It stores the result in the destination operand and sets the carry flag as the complement of borrow.",
	0xBC: "LDBSE LOAD BYTE SIGN-EXTENDED. Signextends the value of the source shortinteger operand and loads it into the destination integer operand.",
	0xBD: "LDBSE LOAD BYTE SIGN-EXTENDED. Signextends the value of the source shortinteger operand and loads it into the destination integer operand.",
	0xBE: "LDBSE LOAD BYTE SIGN-EXTENDED. Signextends the value of the source shortinteger operand and loads it into the destination integer operand.",
	0xBF: "LDBSE LOAD BYTE SIGN-EXTENDED. Signextends the value of the source shortinteger operand and loads it into the destination integer operand.",
	0xC0: "ST STORE WORD. Stores the value of the source (leftmost) word operand into the destination (rightmost) operand.",
	0xC1: "BMOV BLOCK MOVE. Moves a block of word data from one location in memory to another. The source and destination addresses are calculated using indirect addressing with autoincrement. A long register (PTRS) addresses the source and destination pointers, which are stored in adjacent word registers. The source pointer (SRCPTR) is the low word and the destination pointer (DSTPTR) is the high word of PTRS. A word register (CNTREG) specifies the number of transfers. CNTREG must reside in the lower register file; it cannot be windowed. The blocks of word data can be located anywhere in page 00H, but should not overlap. Because the source (SRCPTR) and destination (DSTPTR) pointers are 16 bits wide, this instruction uses nonextended data moves. It cannot operate across page boundaries.",
	0xC2: "ST STORE WORD. Stores the value of the source (leftmost) word operand into the destination (rightmost) operand.",
	0xC3: "ST STORE WORD. Stores the value of the source (leftmost) word operand into the destination (rightmost) operand.",
	0xC4: "STB STORE BYTE. Stores the value of the source (leftmost) byte operand into the destination (rightmost) operand.",
	0xC5: "CMPL COMPARE LONG. Compares the magnitudes of two double-word (long) operands. The operands are specified using the direct addressing mode. The flags are altered, but the operands remain unaffected. If a borrow occurs, the carry flag is cleared; otherwise, it is set.",
	0xC6: "STB STORE BYTE. Stores the value of the source (leftmost) byte operand into the destination (rightmost) operand.",
	0xC7: "STB STORE BYTE. Stores the value of the source (leftmost) byte operand into the destination (rightmost) operand.",
	0xC8: "PUSH PUSH WORD. Pushes the word operand onto the stack.",
	0xC9: "PUSH PUSH WORD. Pushes the word operand onto the stack.",
	0xCA: "PUSH PUSH WORD. Pushes the word operand onto the stack.",
	0xCB: "PUSH PUSH WORD. Pushes the word operand onto the stack.",
	0xCC: "POP POP WORD. Pops the word on top of the stack and places it at the destination",
	0xCD: "BMOVI INTERRUPTIBLE BLOCK MOVE. Moves a block of word data from one location in memory to another. The instruction is identical to BMOV, except that BMOVI is interruptible. The source and destination addresses are calculated using indirect addressing with autoincrement . A long register (PTRS) addresses the source and destination pointers, which are stored in adjacent word registers. The source pointer (SRCPTR) is the low word and the destination pointer (DSTPTR) is the high word of PTRS. A word register (CNTREG) specifies the number of transfers. CNTREG must reside in the lower register file; it cannot be windowed. The blocks of word data can be located anywhere in page 00H, but should not overlap. Because the source (SRCPTR) and destination (DSTPTR) pointers are 16 bits wide, this instruction uses nonexteneded data moves. It cannot operate across page boundaries. (If you need to cross page boundaries, use the EBMOVI instruction.)",
	0xCE: "POP POP WORD. Pops the word on top of the stack and places it at the destination operand.",
	0xCF: "POP POP WORD. Pops the word on top of the stack and places it at the destination operand.",
	0xD0: "JNST JUMP IF STICKY BIT FLAG IS CLEAR. Tests the sticky bit flag. If the flag is set, control passes to the next sequential instruction. If the sticky bit flag is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in range of –128 to +127.",
	0xD1: "JNH JUMP IF NOT HIGHER (UNSIGNED). Tests both the zero flag and the carry flag. If the carry flag is set and the zero flag is clear, control passes to the next sequential instruction. If either the carry flag is clear or the zero flag is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in range of –128 to +127.",
	0xD2: "JGT JUMP IF SIGNED GREATER THAN. Tests both the zero flag and the negative flag. If either flag is set, control passes to the next sequential instruction. If both flags are clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0xD3: "JNC JUMP IF CARRY FLAG IS CLEAR. Tests the carry flag. If the flag is set, control passes to the next sequential instruction. If the carry flag is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0xD4: "JNVT JUMP IF OVERFLOW-TRAP FLAG IS CLEAR. Tests the overflow-trap flag. If the flag is set, this instruction clears the flag and passes control to the next sequential instruction. If the overflow-trap flag is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in range of –128 to +127.",
	0xD5: "JNV JUMP IF OVERFLOW FLAG IS CLEAR. Tests the overflow flag. If the flag is set, control passes to the next sequential instruction. If the overflow flag is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in range of –128 to +127.",
	0xD6: "JGE JUMP IF SIGNED GREATER THAN OR EQUAL. Tests the negative flag. If the negative flag is set, control passes to the next sequential instruction. If the negative flag is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0xD7: "JNE JUMP IF NOT EQUAL. Tests the zero flag. If the flag is set, control passes to the next sequential instruction. If the zero flag is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0xD8: "JST JUMP IF STICKY BIT FLAG IS SET. Tests the sticky bit flag. If the flag is clear, control passes to the next sequential instruction. If the sticky bit flag is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in range of –128 to +127.",
	0xD9: "JH JUMP IF HIGHER (UNSIGNED). Tests both the zero flag and the carry flag. If either the carry flag is clear or the zero flag is set, control passes to the next sequential instruction. If the carry flag is set and the zero flag is clear, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in range of –128 to +127.",
	0xDA: "JLE JUMP IF SIGNED LESS THAN OR EQUAL. Tests both the negative flag and the zero flag. If both flags are clear, control passes to the next sequential instruction. If either flag is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0xDB: "JC JUMP IF CARRY FLAG IS SET. Tests the carry flag. If the carry flag is clear, control passes to the next sequential instruction. If the carry flag is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0xDC: "JVT JUMP IF OVERFLOW-TRAP FLAG IS SET. Tests the overflow-trap flag. If the flag is clear, control passes to the next sequential instruction. If the overflow-trap flag is set, this instruction clears the flag and adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in range of –128 to +127.",
	0xDD: "JV JUMP IF OVERFLOW FLAG IS SET. Tests the overflow flag. If the flag is clear, control passes to the next sequential instruction. If the overflow flag is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in range of –128 to +127.",
	0xDE: "JLT JUMP IF SIGNED LESS THAN. Tests the negative flag. If the flag is clear, control passes to the next sequential instruction. If the negative flag is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0xDF: "JE JUMP IF EQUAL. Tests the zero flag. If the flag is clear, control passes to the next sequential instruction. If the zero flag is set, this instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0xE0: "DJNZ DECREMENT AND JUMP IF NOT ZERO. Decrements the value of the byte operand by 1. If the result is 0, control passes to the next sequential instruction. If the result is not 0, the instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0xE1: "DJNZW DECREMENT AND JUMP IF NOT ZERO WORD. Decrements the value of the word operand by 1. If the result is 0, control passes to the next sequential instruction. If the result is not 0, the instruction adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –128 to +127.",
	0xE2: "TIJMP TABLE INDIRECT JUMP. Causes execution to continue at an address selected from a table of addresses. The first word register, TBASE, contains the 16-bit address of the beginning of the jump table. TBASE can be located in RAM up to FEH without windowing or above FFH with windowing. The jump table itself can be placed at any nonreserved memory location on a word boundary in page FFH. The second word register, INDEX, contains the 16-bit address that points to a register containing a 7-bit value. This value is used to calculate the offset into the jump table. Like TBASE, INDEX can be located in RAM up to FEH without windowing or above FFH with windowing. Note that the 16-bit address contained in INDEX is absolute; it disregards any windowing that may be in effect when the TIJMP instruction is executed. The byte operand, #MASK, is 7-bit immediate data to mask INDEX. #MASK is ANDed with INDEX to determine the offset (OFFSET). OFFSET is multiplied by two, then added to the base address (TBASE) to determine the destination address (DEST X) in page FFH. ",
	0xE3: "EBR EXTENDED BRANCH INDIRECT. Continues execution at the address specified in the operand word register. This instruction is an unconditional indirect jump to anywhere in the 16-Mbyte address space. EBR shares its opcode (E3) with the BR instruction. To differentiate between the two, the compiler sets the least-significant bit of treg for the EBR instruction. For example: EBR [50] becomes E351 when compiled.",
	0xE4: "EBMOVI EXTENDED INTERRUPTIBLE BLOCK MOVE. Moves a block of word data from one memory location to another. This instruction allows you to move blocks of up to 64K words between any two locations in the 16-Mbyte address space. This instruction is interruptible. The source and destination addresses are calculated using the extended indirect with autoincrement addressing mode. A quadword register (PTRS) addresses the 24-bit pointers, which are stored in adjacent doubleword registers. The source pointer (SRCPTR) is the low double-word and the destination pointer is the high double-word of PTRS. A word register (CNTREG) specifies the number of transfers. This register must reside in the lower register file; it cannot be windowed. The blocks of data can reside anywhere in memory, but should not overlap.",
	0xE5: "Reserved",
	0xE6: "EJMP EXTENDED JUMP. Adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The operand may be any address in the entire address space. The offset must be in the range of +8,388,607 to –8,388,608 for 24-bit addresses. This instruction is an unconditional, relative jump to anywhere in the 16-Mbyte address space. It functions only in extended addressing mode.",
	0xE7: "LJMP LONG JUMP. Adds to the program counter the offset between the end of this instruction and the target label, effecting the jump. The offset must be in the range of –32,768 to +32,767. ",
	0xE8: "ELD EXTENDED LOAD WORD. Loads the value of the source word operand into the destination operand. This instruction allows you to move data from anywhere in the 16-Mbyte address space into the lower register file.",
	0xE9: "ELD EXTENDED LOAD WORD. Loads the value of the source word operand into the destination operand. This instruction allows you to move data from anywhere in the 16-Mbyte address space into the lower register file.",
	0xEA: "ELDB EXTENDED LOAD BYTE. Loads the value of the source byte operand into the destination operand. This instruction allows you to move data from anywhere in the 16-Mbyte address space into the lower register file.",
	0xEB: "ELDB EXTENDED LOAD BYTE. Loads the value of the source byte operand into the destination operand. This instruction allows you to move data from anywhere in the 16-Mbyte address space into the lower register file.",
	0xEC: "DPTS DISABLE PERIPHERAL TRANSACTION SERVER (PTS). Disables the peripheral transaction server (PTS).",
	0xED: "EPTS ENABLE PERIPHERAL TRANSACTION SERVER (PTS). Enables the peripheral transaction server (PTS).",
	0xEE: "(Note 1) Reserved",
	0xEF: "LCALL LONG CALL. Pushes the contents of the program counter (the return address) onto the stack, then adds to the program counter the offset between the end of this instruction and the target label, effecting the call. The offset must be in the range of –32,768 to +32,767.",
	0xF0: "RET RETURN FROM SUBROUTINE. Pops the PC off the top of the stack.",
	0xF1: "ECALL EXTENDED CALL. Pushes the contents of the program counter (the return address) onto the stack, then adds to the program counter the offset between the end of this instruction and the target label, effecting the call. The operand may be any address in the address space. This instruction is an unconditional relative call to anywhere in the 16-Mbyte address space. It functions only in extended addressing mode.",
	0xF2: "PUSHF PUSH FLAGS. Pushes the PSW onto the top of the stack, then clears it. Clearing the PSW disables interrupt servicing. Interrupt calls cannot occur immediately following this instruction.",
	0xF3: "POPF POP FLAGS. Pops the word on top of the stack and places it into the PSW. Interrupt calls cannot occur immediately following this instruction.",
	0xF4: "PUSHA PUSH ALL. This instruction is used instead of PUSHF, to support the eight additional interrupts. It pushes two words — PSW/INT_MASK and INT_MASK1/WSR — onto the stack. This instruction clears the PSW, INT_MASK, and INT_MASK1 registers and decrements the SP by 4. Interrupt calls cannot occur immediately following this instruction.",
	0xF5: "POPA POP ALL. This instruction is used instead of POPF, to support the eight additional interrupts. It pops two words off the stack and places the first word into the INT_MASK1/WSR register pair and the second word into the PSW/INT_MASK register-pair. This instruction increments the SP by 4. Interrupt calls cannot occur immediately following this instruction. ",
	0xF6: "IDLPD IDLE/POWERDOWN. Depending on the 8-bit value of the KEY operand, this instruction causes the device to: • enter idle mode, if KEY=1, • enter powerdown mode, if KEY=2, • execute a reset sequence, if KEY > 3. The bus controller completes any prefetch cycle in progress before the CPU stops or resets.",
	0xF7: "TRAP SOFTWARE TRAP. This instruction causes an interrupt call that is vectored through location FF2010H. The operation of this instruction is not affected by the state of the interrupt enable flag (I) in the PSW. Interrupt calls cannot occur immediately following this instruction.",
	0xF8: "CLRC CLEAR CARRY FLAG. Clears the carry flag.",
	0xF9: "SETC SET CARRY FLAG. Sets the carry flag.",
	0xFA: "DI DISABLE INTERRUPTS. Disables maskable interrupts. Interrupt calls cannot occur after this instruction.",
	0xFB: "EI ENABLE INTERRUPTS. Enables maskable interrupts following the execution of the next statement. Interrupt calls cannot occur immediately following this instruction.",
	0xFC: "CLRVT CLEAR OVERFLOW-TRAP FLAG. Clears the overflow-trap flag.",
	0xFD: "NOP NO OPERATION. Does nothing. Control passes to the next sequential instruction.",
	0xFE: "Prefix for signed multiplication and division.",
	0xFF: "RST RESET SYSTEM. Initializes the PSW to zero, the PC to FF2080H, and the pins and SFRs to their reset values. Executing this instruction causes the RESET# pin to be pulled low for 16 state times.",
}

// byte to description
var signedDescriptions = map[byte]string{
	0x4C: "MUL (3 operands) MULTIPLY INTEGERS. Multiplies the two source integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x4D: "MUL (3 operands) MULTIPLY INTEGERS. Multiplies the two source integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x4E: "MUL (3 operands) MULTIPLY INTEGERS. Multiplies the two source integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x4F: "MUL (3 operands) MULTIPLY INTEGERS. Multiplies the two source integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x5C: "MULB (3 operands) MULTIPLY SHORT-INTEGERS. Multiplies the two source short-integer operands, using signed arithmetic, and stores the 16-bit result into the destination integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x5D: "MULB (3 operands) MULTIPLY SHORT-INTEGERS. Multiplies the two source short-integer operands, using signed arithmetic, and stores the 16-bit result into the destination integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x5E: "MULB (3 operands) MULTIPLY SHORT-INTEGERS. Multiplies the two source short-integer operands, using signed arithmetic, and stores the 16-bit result into the destination integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x5F: "MULB (3 operands) MULTIPLY SHORT-INTEGERS. Multiplies the two source short-integer operands, using signed arithmetic, and stores the 16-bit result into the destination integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x6C: "MUL (2 operands) MULTIPLY INTEGERS. Multiplies the source and destination integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x6D: "MUL (2 operands) MULTIPLY INTEGERS. Multiplies the source and destination integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x6E: "MUL (2 operands) MULTIPLY INTEGERS. Multiplies the source and destination integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x6F: "MUL (2 operands) MULTIPLY INTEGERS. Multiplies the source and destination integer operands, using signed arithmetic, and stores the 32-bit result into the destination long-integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x7C: "MULB (2 operands) MULTIPLY SHORT-INTEGERS. Multiplies the source and destination short-integer operands, using signed arithmetic, and stores the 16-bit result into the destination integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x7D: "MULB (2 operands) MULTIPLY SHORT-INTEGERS. Multiplies the source and destination short-integer operands, using signed arithmetic, and stores the 16-bit result into the destination integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x7E: "MULB (2 operands) MULTIPLY SHORT-INTEGERS. Multiplies the source and destination short-integer operands, using signed arithmetic, and stores the 16-bit result into the destination integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x7F: "MULB (2 operands) MULTIPLY SHORT-INTEGERS. Multiplies the source and destination short-integer operands, using signed arithmetic, and stores the 16-bit result into the destination integer operand. The sticky bit flag is undefined after the instruction is executed.",
	0x8C: "DIV DIVIDE INTEGERS. Divides the contents of the destination long-integer operand by the contents of the source integer word operand, using signed arithmetic. It stores the quotient into the low-order word of the destination (i.e., the word with the lower address) and the remainder into the high-order word. The following two statements are performed concurrently.",
	0x8D: "DIV DIVIDE INTEGERS. Divides the contents of the destination long-integer operand by the contents of the source integer word operand, using signed arithmetic. It stores the quotient into the low-order word of the destination (i.e., the word with the lower address) and the remainder into the high-order word. The following two statements are performed concurrently.",
	0x8E: "DIV DIVIDE INTEGERS. Divides the contents of the destination long-integer operand by the contents of the source integer word operand, using signed arithmetic. It stores the quotient into the low-order word of the destination (i.e., the word with the lower address) and the remainder into the high-order word. The following two statements are performed concurrently.",
	0x8F: "DIV DIVIDE INTEGERS. Divides the contents of the destination long-integer operand by the contents of the source integer word operand, using signed arithmetic. It stores the quotient into the low-order word of the destination (i.e., the word with the lower address) and the remainder into the high-order word. The following two statements are performed concurrently.",
	0x9C: "DIVB DIVIDE SHORT-INTEGERS. Divides the contents of the destination integer operand by the contents of the source short-integer operand, using signed arithmetic. It stores the quotient into the low-order byte of the destination (i.e., the word with the lower address) and the remainder into the highorder byte. The following two statements are performed concurrently.",
	0x9D: "DIVB DIVIDE SHORT-INTEGERS. Divides the contents of the destination integer operand by the contents of the source short-integer operand, using signed arithmetic. It stores the quotient into the low-order byte of the destination (i.e., the word with the lower address) and the remainder into the highorder byte. The following two statements are performed concurrently.",
	0x9E: "DIVB DIVIDE SHORT-INTEGERS. Divides the contents of the destination integer operand by the contents of the source short-integer operand, using signed arithmetic. It stores the quotient into the low-order byte of the destination (i.e., the word with the lower address) and the remainder into the highorder byte. The following two statements are performed concurrently.",
	0x9F: "DIVB DIVIDE SHORT-INTEGERS. Divides the contents of the destination integer operand by the contents of the source short-integer operand, using signed arithmetic. It stores the quotient into the low-order byte of the destination (i.e., the word with the lower address) and the remainder into the highorder byte. The following two statements are performed concurrently.",
}
